runApp()
runApp()
runApp()
runApp()
runApp()
runApp('../tsr2')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
?selectInput
?numericInput
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp()
runApp()
runApp()
runApp('Dropbox/MYSHINY/tsr')
## Options and packages ---------------------------------------------------
#install.packages(c("tsModel","Epi","splines","lubridate"))
library(tsModel) ; library("splines")
shiny::runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
runApp('Dropbox/MYSHINY/tsr')
install.packages(c("backports", "boot", "callr", "class", "cli", "cmprsk", "curl", "DBI", "dbplyr", "digest", "dlnm", "dplyr", "ellipsis", "fansi", "forcats", "fs", "ggplot2", "glue", "gnm", "haven", "hms", "htmltools", "httpuv", "jsonify", "jsonlite", "KernSmooth", "knitr", "later", "lattice", "lme4", "lubridate", "lwgeom", "mapdeck", "maptools", "MASS", "Matrix", "meta", "metafor", "mgcv", "mime", "mixmeta", "modelr", "mvmeta", "netmeta", "nlme", "nloptr", "nnet", "pkgconfig", "plyr", "prettyunits", "processx", "promises", "ps", "purrr", "qvcalc", "R6", "Rcpp", "RcppArmadillo", "RcppEigen", "reshape2", "rgdal", "RgoogleMaps", "rmarkdown", "rsconnect", "rstudioapi", "rvest", "scales", "selectr", "sfheaders", "shiny", "shinyjs", "sp", "spatial", "stringi", "survival", "sys", "tidyr", "tidyselect", "tidyverse", "tinytex", "tsibble", "vctrs", "whisker", "withr", "xfun", "xml2", "yaml"))
?glmm
################################################################################
# MCC-MMT SUBPROJECT
# File updated in Barcelona, 26 Nov 2019
################################################################################
# PREPARE AND CLEAN UP COUNTRY DATASETS FOR THE ANALYSIS
################################################################################
################################################################################
# SET UP
# REMOVE OBJECTS
rm(list=ls())
# LOAD LIBRARIES
library(dlnm) ; library(splines) ; library(tsModel); library(mgcv) ;library(foreign)
# LOAD FRANCESCO DATA
ind <- "~/Dropbox/MCC_Aurelio/September_2020"
load(paste(ind,"MCCdata_20200907.RData",sep="/"))
# SELECT DATA
subcountry <- sort(c("arg0515",
"aus8809",
"bra9711",
"can8615",
"chl0414",
"chi9615",
"col9813",
"crc0017",
"cze9415",
"ecu1418",
"est9715",
"fnl9414",
"fra0014",
"ger9315",
"grc0110",
"gua0916",
"irn0215",
"irl8407",
"ita0615",
"jap7215",
"kuw0016",
"mex9814",
"mld0110",
"net9516c",
"nor6918",
"pan1316",
"par0416",
"per0814",
"phi0610",
"por8018",
"pue0916",
"rom9416",
"sa9713",
"kor9718",
"spa9014",
"swe9016",
"sui9513",
"twn9414",
"tha9908",
"uk9016",
"uru1216",
"usa7306",
"vie0913"))
dlist <- dlist[cities$country%in%subcountry]
cities <- cities[cities$country%in%subcountry,]
countries <- countries[countries$country%in%subcountry,]
################################################################################
# EXCLUDE CITIES, PERIODS AND OUTLIERS
# EXCLUDE TANGSHAN IN CHINA, WITH WEIRD DEATH COUNTS DISTRIBUTION
dlist[cities$city=="tngs.chi9615"] <- NULL
cities <- cities[-which(cities$city=="tngs.chi9615"),]
# EXCLUDE NANJING IN CHINA, WITH NO COUNTS FOR ALL/NONEXTERNAL MORTALITY
dlist[cities$city=="nnjn.chi9615"] <- NULL
cities <- cities[-which(cities$city=="nnjn.chi9615"),]
# EXCLUDE EARLIER YEARS FOR JAPAN
for(i in which(cities$country%in%"jap7215"))
dlist[[i]] <- dlist[[i]][dlist[[i]]$year>=1985,]
# EXCLUDE EARLIER YEARS FOR NORWAY
for(i in which(cities$country%in%"nor6916"))
dlist[[i]] <- dlist[[i]][dlist[[i]]$year>=1985,]
# SET OUTLIERS TO MISSING
for(i in seq(nrow(cities))) {
if(is.null(dlist[[i]]$all)) dlist[[i]]$nonext[dlist[[i]]$outlierm==1] <- NA else
dlist[[i]]$all[dlist[[i]]$outlierm==1] <- NA
dlist[[i]]$tmean[dlist[[i]]$outliert==1] <- NA
}
rownames(cities) <- seq(nrow(cities))
cities[1:4] <- as.data.frame(as.matrix(cities[1:4]))
rownames(countries) <- seq(nrow(countries))
library(tidyverse)
id_city <- filter(cities, countryname == "Spain") %>% pull(city)
subset_spain <- dlist[id_city]
subset_spain
id_city
names(subset_spain)
View(countries)
View(countries)
# LOAD FRANCESCO DATA
ind <- "~/Dropbox/MCC_Aurelio/September_2020"
load(paste(ind,"MCCdata_20200907.RData",sep="/"))
library(tidyverse)
id_city <- filter(cities, countryname == "Spain") %>% pull(city)
subset_spain <- dlist[id_city]
names(subset_spain)
install.packages("hysplit", lib="/Library/Frameworks/R.framework/Versions/3.6/Resources/library")
install.packages("splitr", lib="/Library/Frameworks/R.framework/Versions/3.6/Resources/library")
?forest
library(meta)
?forest
library(tsModel);
?tsmodel
??tsmodel
data(balt
)
data(balt)
data<-data(balt)
data
library(tsModel)
data(balt)
balt
setwd("~/Dropbox/UPCXIVSC_RST/2 Martes/Datos")
setwd("~/Dropbox/UPCXIVSC_RST/2 Martes")
# librerias manejo de datos
library(tidyverse)
library(lubridate)
library(fs)
library(tsibble)
library(feasts)
# librerias series temporales
library(tsModel)
library(splines)
library(dlnm)
# cargar funciones R
source("./Datos/QAICM.R")
source("./Datos/findmin.R")
dir_ls("Datos", regexp = "csv$")
# importar y unir archivos de datos
data_valencia <- dir_ls("Datos", regexp = "csv$") %>%
map(read.csv2) %>%
reduce(left_join, by = "fecha")
data_valencia
# formato fecha
data_valencia <- mutate(data_valencia,
fecha = mdy(fecha)) %>%
as_tsibble(index = "fecha")
# duplicados
is_duplicated(data_valencia, index = fecha)
# lagunas
has_gaps(data_valencia)
# generar variables de calendario
data_valencia <- mutate(data_valencia,
yr = as.factor(year(fecha)),
mo = month(fecha, label = TRUE),
dy = day(fecha),
wd = wday(fecha, label = TRUE, abbr = FALSE),
wk = if_else(wd %in% c("domingo", "sabado"), 1, 0),
trend = row_number())
str(data_valencia)
# generar variables de calendario
data_valencia <- mutate(data_valencia,
yr = as.factor(year(fecha)),
mo = month(fecha, label = TRUE),
dy = day(fecha),
wd = wday(fecha),
wk = if_else(wd > 6, 1, 0),
trend = row_number())
data_valencia
str(data_valencia)
View(data_valencia)
?wday
# generar variables de calendario
data_valencia <- mutate(data_valencia,
yr = as.factor(year(fecha)),
mo = month(fecha, label = TRUE),
dy = day(fecha),
wd = wday(fecha),
wk = if_else(wd %in% 6:7, 1, 0),
trend = row_number())
View(data_valencia)
# mortalidad
# serie temporal
ggplot(data_valencia,
aes(fecha, tm)) +
geom_line(colour = 'blue') +
scale_x_date(date_breaks = "2 years", date_labels = "%Y") +
scale_y_continuous(breaks = seq(0, 50, 5)) +
labs(x = "Fecha", y = "Num. muertes") +
theme_minimal()
# box plot años
ggplot(data_valencia,
aes(yr, tm))  +
geom_boxplot()
# box plot años
ggplot(data_valencia,
aes(yr, tm))  +
geom_violin()
# box plot meses
ggplot(data_valencia,
aes(mo, tm))  +
geom_boxplot()
# box plot dia de la semana
ggplot(data_valencia,
aes(wd, tm))  +
geom_boxplot()
# generar variables de calendario
data_valencia <- mutate(data_valencia,
yr = as.factor(year(fecha)),
mo = month(fecha, label = TRUE),
dy = day(fecha),
wd = wday(fecha, label = TRUE, abbr = TRUE),
wk = if_else(wd %in% c("domingo", "sábado"), 1, 0),
trend = row_number())
# box plot dia de la semana
ggplot(data_valencia,
aes(wd, tm))  +
geom_boxplot()
# descomposicion
data_valencia %>%
model(STL(tm ~ season(period = 365.25))) %>%
components() %>%
autoplot()
# temperatura
# serie temporal
ggplot(data_valencia,
aes(fecha, tmean)) +
geom_line(colour = 'red') +
scale_x_date(date_breaks = "2 years", date_labels = "%Y") +
scale_y_continuous(breaks = seq(0, 35, 5)) +
labs(x = "Fecha", y = "Temperatura (ºC)") +
theme_minimal()
# box plot años
ggplot(data_valencia,
aes(yr, tmean))  +
geom_boxplot()
# blox plot meses
ggplot(data_valencia,
aes(mo, tmean))  +
geom_boxplot()
# box plot dia de la semana
ggplot(data_valencia,
aes(wd, tmean))  +
geom_boxplot()
# mortalidad
# serie temporal
ggplot(data_valencia,
aes(fecha, tm)) +
geom_line(colour = 'blue') +
scale_x_date(date_breaks = "2 years", date_labels = "%Y") +
scale_y_continuous(breaks = seq(0, 50, 5)) +
labs(x = "Fecha", y = "Num. muertes") +
theme_minimal()
# box plot años
ggplot(data_valencia,
aes(yr, tm))  +
geom_boxplot()
# box plot meses
ggplot(data_valencia,
aes(mo, tm))  +
geom_boxplot()
# descomposicion
data_valencia %>%
model(STL(tm ~ season(period = 365.25))) %>%
components() %>%
autoplot()
# serie temporal mortalidad diaria
# modelo
model0 <- glm(tm ~ 1, data=data_valencia, family=quasipoisson)
summary(model0)
# autocorrelacion
acf(data_valencia$tm, lag=30)
# variables de calendario
# modelo
model1 <- glm(tm ~ factor(yr), data=data_valencia, family=quasipoisson)
summary(model1)
# prediccion
pred1 <- predict(model1, type="response")
lines(data_valencia$fecha, pred1, lwd=2, col="blue")
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
lines(data_valencia$fecha, pred1, lwd=2, col="blue")
# autocorrelacion residual
res1 <- residuals(model1, type="response")
acf(res1, lag=30)
# modelo
model2 <- glm(tm ~ factor(yr) + factor(mo), data=data_valencia, family=quasipoisson)
summary(model2)
# prediccion
pred2 <- predict(model2, type="response")
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
lines(data_valencia$fecha, pred2, lwd=2, col="blue")
# autocorrelacion residual
res2 <- residuals(model2, type="response")
acf(res2, lag=30)
# funciones periodicas
# funcion periodica anual
fourier1 <- harmonic(data_valencia$fecha,nfreq=1,period=365.25)
fourier1
# modelo
model3 <- glm(tm ~ trend + fourier1 , data=data_valencia, family=quasipoisson)
summary(model3)
# prediccion
pred3 <- predict(model3, type="response")
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
lines(data_valencia$fecha, pred3, lwd=2, col="seagreen")
# autocorrelacion residual
res3 <- residuals(model3, type="response")
acf(res3, lag=30)
# funcion periodica semestral
fourier2 <- harmonic(data_valencia$fecha,nfreq=2,period=365.25)
str(fourier2)
names(fourier2)
fourier2
# modelo
model4 <- glm(tm ~ trend + fourier2 , data=data_valencia, family=quasipoisson)
summary(model4)
# prediccion
pred4 <- predict(model4, type="response")
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
lines(data_valencia$fecha, pred4, lwd=2, col="seagreen")
# funcion periodica cuatrimestral
fourier3 <- harmonic(data_valencia$fecha,nfreq=3,period=365.25)
# modelo
model5 <- glm(tm ~ trend + fourier3 , data=data_valencia, family=quasipoisson)
summary(model5)
# autocorrelacion residual
res5 <- residuals(model5, type="response")
acf(res5, lag=30)
# funcion periodica trimestral
fourier4 <- harmonic(data_valencia$fecha,nfreq=4,period=365.25)
# modelo
model6 <- glm(tm ~ trend + fourier4 , data=data_valencia, family=quasipoisson)
summary(model6)
# prediccion
pred6 <- predict(model6, type="response")
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
lines(data_valencia$fecha, pred6, lwd=2, col="seagreen")
lines(data_valencia$fecha, pred5, lwd=2, col="red")
# prediccion
pred5 <- predict(model5, type="response")
lines(data_valencia$fecha, pred5, lwd=2, col="red")
# autocorrelacion residual
res6 <- residuals(model6, type="response")
acf(res6, lag=30)
# comparar modelos con AIC
QAICM(model3, "dev")
QAICM(model4, "dev")
QAICM(model5, "dev")
QAICM(model6, "dev")
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
lines(data_valencia$fecha, pred5, lwd=2, col="red")
# funciones flexibles
# funcion flexible 1 df/ano
spl <- ns(data_valencia$trend,df=12)
# modelo
model7 <- glm(tm ~ spl , data=data_valencia, family=quasipoisson)
summary(model7)
# prediccion
pred7 <- predict(model7, type="response")
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
lines(data_valencia$fecha, pred7, lwd=2, col="red")
# autocorrelacion residual
res7<- residuals(model7, type="response")
acf(res7, lag=30)
# funcion flexible 3 df/ano
spl <- ns(data_valencia$trend, df=36)
# modelo
model8 <- glm(tm ~ spl , data=data_valencia, family=quasipoisson)
summary(model8)
# prediccion
pred8 <- predict(model8, type="response")
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
lines(data_valencia$fecha, pred8, lwd=2, col="red")
# funcion flexible 5 df/ano
spl <- ns(data_valencia$trend, df=60)
# modelo
model9 <- glm(tm ~ spl , data=data_valencia, family=quasipoisson)
summary(model9)
# prediccion
pred9 <- predict(model9, type="response")
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
lines(data_valencia$fecha, pred9, lwd=2, col="red")
# autocorrelacion residual
res9 <- residuals(model9, type="response")
acf(res9, lag=30)
# funcion flexible 7 df/ano
spl <- ns(data_valencia$trend, df=84)
# modelo
model10 <- glm(tm ~ spl , data=data_valencia, family=quasipoisson)
summary(model10)
# prediccion
pred10 <- predict(model10, type="response")
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
lines(data_valencia$fecha, pred10, lwd=2, col="red")
# autocorrelacion residual
res10 <- residuals(model10, type="response")
acf(res10, lag=30)
# comparar modelos con AIC
QAICM(model7, "dev")
QAICM(model8, "dev")
QAICM(model9, "dev")
QAICM(model10, "dev")
# comparar ajuste con variables de calendario, funciones periodicas y funciones flexibles
# prediccion
plot(data_valencia$fecha, data_valencia$tm, pch=19, cex=0.2, col=grey(0.6),
ylab="Num. muertes", xlab="Fecha")
lines(data_valencia$fecha, pred2, lwd=2, col="blue")
lines(data_valencia$fecha, pred6, lwd=2, col="seagreen")
lines(data_valencia$fecha, pred10, lwd=2, col="red")
# analisis temperatura
# ajuste lineal
btmean1 <- onebasis(data_valencia$tmean, df=1)
# analisis temperatura
# ajuste lineal
btmean1 <- onebasis(data_valencia$tmean, df=1)
model.tmean1 <- glm(tm ~ spl + btmean1, data=data_valencia, family=quasipoisson)
min1 <- min(data_valencia$tmean)
pred1 <- crosspred(btmean1, model.tmean1, cen=min1)
plot(pred1, xlab="Temperatura (ºC)", ylab="Riesgo de mortalidad")
# ajuste no-lienal con df=2
btmean2 <- onebasis(data_valencia$tmean, df=2)
model.tmean2 <- glm(tm ~ spl + btmean2, data=data_valencia, family=quasipoisson)
min2 <- findmin(btmean2, model.tmean2)
min2
pred2 <- crosspred(btmean2, model.tmean2, cen=min2)
plot(pred2, xlab="Temperatura (ºC)", ylab="Riesgo de mortalidad")
# ajuste no-lienal con df=3
btmean3 <- onebasis(data_valencia$tmean, df=3)
model.tmean3 <- glm(tm ~ spl + btmean3, data=data_valencia, family=quasipoisson)
min3 <- findmin(btmean3, model.tmean3)
pred3 <- crosspred(btmean3, model.tmean3, cen=min3)
plot(pred3, xlab="Temperatura (ºC)", ylab="Riesgo de mortalidad")
min3
# Ajuste no-lienal con df=4
btmean4 <- onebasis(data_valencia$tmean, df=4)
model.tmean4 <- glm(tm ~ spl + btmean4, data=data_valencia, family=quasipoisson)
min4 <- findmin(btmean4, model.tmean4)
min4
pred4 <- crosspred(btmean4, model.tmean4, cen=min4)
plot(pred4, xlab="Temperatura (ºC)", ylab="Riesgo de mortalidad")
# comparar modelos con AIC
QAICM(model.tmean1, "dev")
QAICM(model.tmean2, "dev")
QAICM(model.tmean3, "dev")
QAICM(model.tmean4, "dev")
bozono1 <- onebasis(data_valencia$o38, df=1)
model.ozono1 <- glm(tm ~ spl + bozono1, data=data_valencia, family=quasipoisson)
min <- min(data_valencia$o38, na.rm=TRUE)
pred <- crosspred(bozono1, model.ozono1, cen=min)
plot(pred, xlab="Ozono (8h)", ylab="Riesgo de mortalidad")
# Ajuste no-lienal con df=2
bozono2 <- onebasis(data_valencia$o38, df=2)
model.ozono2 <- glm(tm ~ spl + bozono2, data=data_valencia, family=quasipoisson)
pred <- crosspred(bozono2, model.ozono2, cen=min)
plot(pred, xlab="Ozono (8h)", ylab="Riesgo de mortalidad")
# comparar modelos con AIC
QAICM(model.ozono1, "dev")
QAICM(model.ozono2, "dev")
plot(pred4, xlab="Temperatura (ºC)", ylab="Riesgo de mortalidad")
